# ⚙️ mcp-devtools: SSE経由の多機能開発ツールMCPサーバー

  - 🔧 `mcp-devtools` は、包括的な開発ツール群を提供します: [ℹ️ 利用可能なツール](#%E2%84%B9%EF%B8%8F-%E5%88%A9%E7%94%A8%E5%8F%AF%E8%83%BD%E3%81%AA%E3%83%84%E3%83%BC%E3%83%AB)
      - 🎋 Git管理操作 (`git_status`, `git_stage_and_commit`, `git_diff`, `git_log`, `git_create_branch`, `git_checkout`, `git_show`)
      - 📁 Gitファイル操作 (`git_read_file`, `git_apply_diff`)
      - 📂 直接ファイル操作 (`write_to_file`) [ℹ️ 直接編集 vs AI支援編集](#-%E7%9B%B4%E6%8E%A5%E3%82%B3%E3%83%BC%E3%83%89%E7%B7%A8%E9%9B%86-vs--ai%E6%94%AF%E6%8F%B4%E7%B7%A8%E9%9B%86)
      - 📂 直接ファイル操作 (`write_to_file`) [ℹ️ 直接編集 vs AI支援編集](#-%E7%9B%B4%E6%8E%A5%E3%82%B3%E3%83%BC%E3%83%89%E7%B7%A8%E9%9B%86-vs--ai%E6%94%AF%E6%8F%B4%E7%B7%A8%E9%9B%86)
      - 🤖 [Aider](https://github.com/Aider-AI/aider)を使用したAI支援ファイル操作 (`ai_edit`)
      - 🖥️ ターミナルコマンド実行 (`execute_command`) [⚠️ 自動化関連のセキュリティ考慮事項](#-%E8%87%AA%E5%8B%95%E5%8C%96%E9%96%A2%E9%80%A3%E3%81%AE%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3%E8%80%83%E6%85%AE%E4%BA%8B%E9%A0%85)

<details>
<summary> <h4> ℹ️ 推奨 Aider 設定 </h4> </summary>

- リポジトリのルート（推奨）またはホームディレクトリ（`~/.aider.conf.yml`）に `.aider.conf.yml` を作成／コピーします。
- リポジトリのルートにある `.aider.conf.yml` をテンプレートとして使用し、必要に応じて（モデル、APIキー、自動コミット動作、include/exclude など）調整してください。
- サーバーはワークスペース内の `.aider.conf.yml` を自動的に読み込みます。リポジトリルートまたは HOME に置けば、多くのワークフローで十分です。
- 各オプションの詳細は [📄 公式 Aider ドキュメント](https://aider.chat/docs/config.html) を参照してください。

</details>

### [⬇️ ダウンロードへスキップ](#1%EF%B8%8F%E2%83%A3-%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6)

## ⛎ ユースケース

  - 🌐 [MCP-SuperAssistant](https://github.com/srbhptl39/MCP-SuperAssistant/) や類似のプロジェクトを介して、ChatGPT、Google Gemini、AI Studio、Perplexity、Grok、OpenRouter Chat、DeepSeek、Kagi、T3 Chatなどのオンラインチャットベースのアシスタントを拡張し、ローカルファイル、git、ターミナルコマンド実行、AI支援ファイル編集機能への直接アクセスを可能にします。
  - 👩🏻‍💻 Cursor、Windsurf、またはRoo Code、Cline、Copilot、AugmentなどのVSCode拡張機能のようなコードエディタを、直感的なGit管理とAI支援ファイル編集機能で強化し、時間を無駄にする厄介なdiff適用失敗や、慎重に設計された自動化ワークフローを破壊する `Roo having trouble...` に別れを告げましょう。Aiderはdiffを正しく適用するようです！（それでもうまく機能しない場合は、`ai_edit` ツールに異なる `edit_format` [パラメータ](#ai_edit)を明示的に渡して、AIモデルに最適な方法を見つけてみてください）：
      - `unidiff` はGPTでより良く機能するようです
      - `diff-fenced` はGeminiで最高のパフォーマンスを発揮します
      - `diff` はすべてのモデルでバランスの取れた迅速な結果を提供します（デフォルト）
      - `whole` はファイルを単純に上書きするため最も遅いですが、最も信頼性の高いオプションです

## ♒ [Roo](https://github.com/RooCodeInc/Roo-Code) ワークフロー

ℹ️ ルール順守のため、Roo Code の `experimental` 設定で `power steering` を有効にしてください。

https://github.com/user-attachments/assets/4d218e5e-906c-4d24-abc3-09ab0acdc1d0

### 😻 Vibe-Driven Dev Flow: [pure vibes](https://en.wikipedia.org/wiki/Vibe_coding) にインスパイア、人手ほぼ無しの“Vibing”向けに最適化

<details>
<summary> <h4> 🪪 説明を表示 </h3> </summary>

- `mcp-devtools` サーバーに Roo を接続し、通常どおりコーディング。ただし「💻 Code」ではなく「❓ Ask」モードを使用。利用可能なら AI が自動で `ai_edit` を使って変更を適用します。

</details>

### 🙀 Spec-Driven Dev Flow: [spooky vibes](https://kiro.dev) にインスパイア、アジャイルな人間参加に最適化

<details>
<summary> <h4> 🪪 説明を表示 </h3> </summary>

- アジャイルな仕様駆動フローを体験するには、[.kiroomodes](https://github.com/daoch4n/mcp-devtools/blob/main/.kiroomodes) ファイルと [.kiroo/](https://github.com/daoch4n/mcp-devtools/tree/main/.kiroo) フォルダをリポジトリのルートに配置し、`.roomodes` と `.roo/` にリネームしてください：
  - `✒️ Agile Writer` でエピック仕様・ユーザーストーリーの作成を開始
  - 承認後、`✏️ Agile Architect` に自動切替してエピック設計を作成
  - 次の承認後、`🖊️ Agile Planner` に自動切替してエピックタスクを作成
  - 最終承認後、`🖋️ Agile Dev` に自動切替してエピックのコード実装をオーケストレーションし、各コミットのレビューを実行
  - ℹ️ `ai_edit` を使わない場合、上流の `🖋️ Agile Dev` におけるセルフコードレビューの流れを壊さないよう、ネイティブの「💻 Code」がタスク完了前に結果をコミットするよう誘導するとよいでしょう。

</details>

### 😼 Plan-Driven Dev Flow: [minimal vibes](https://github.com/marv1nnnnn/rooroo) にインスパイア、ウォーターフォール型の“人手ほぼ無し”に最適化

<details>
<summary> <h4> 🪪 説明を表示 </h3> </summary>

- 構造化されたウォーターフォールフローを体験するには、[.rooroomodes](https://github.com/daoch4n/mcp-devtools/blob/main/.rooroomodes) ファイルと [.rooroo/](https://github.com/daoch4n/mcp-devtools/tree/main/.rooroo) フォルダをリポジトリのルートに配置し、`.roomodes` と `.roo/` にリネームしてください：
  - `🧭 Rooroo Navigator` エージェント：上位フローマネージャー。プロジェクト調整、タスクオーケストレーション、ライフサイクル、委譲を担当。`🗓️ Rooroo Planner` が作成した、または不要と判断された場合は自ら作成した `context.md` をタスクに提供
  - `👩🏻‍💻 Rooroo Developer` エージェント：すべてのコード変更をサブエージェントに委譲し Aider の結果をレビュー。`ai_edit` が使えない場合は自ら実装
  - `📊 Rooroo Analyzer` エージェント：研究・コード分析を担当
  - `🗓️ Rooroo Planner` エージェント：複雑な目標を、他のエージェントが実行可能な明確なサブタスクに分解。`context.md` の主要提供者
  - `💡 Rooroo Idea Sparker` エージェント：ブレストの相棒であり、イノベーションの触媒

</details>

## 1️⃣ 前提条件

  - Python 3.12, [uv](https://github.com/astral-sh/uv)

### 🐧 Linux/macOS

```bash
curl -LsSf https://astral.sh/uv/install.sh | sh
```

### 🪟 Windows

```powershell
powershell -ExecutionPolicy ByPass -c "irm https://astral.sh/uv/install.ps1 | iex"
```

## 2️⃣ 使用方法

### 🐍 PyPiから実行

```bash
uvx mcp-devtools -p 1337
```

### 🐈‍⬛ GitHubから実行

#### 🐧 Linux/macOS

```bash
git clone "https://github.com/daoch4n/zen-ai-mcp-devtools/"
cd zen-ai-mcp-devtools
./server.sh -p 1337
```

#### 🪟 Windows

```powershell
git clone "https://github.com/daoch4n/zen-ai-mcp-devtools/"
cd zen-ai-mcp-devtools
.\server.ps1 -p 1337
```

## 3️⃣ MCPサーバー設定

`mcp-devtools` をAIアシスタントと統合するには、MCP設定ファイルに次の設定を追加します：

```json
{
  "mcpServers": {
    "devtools": {
      "url": "http://127.0.0.1:1337/sse",
      "disabled": false,
      "alwaysAllow": [],
      "timeout": 900
    }
  }
}
```

## 4️⃣ [AIシステムプロンプト](https://github.com/daoch4n/research/tree/ai/prompt-engineering/google-whitepaper)の例

```
あなたは開発ツールにアクセスできるAIアシスタントです。
git管理、ファイル操作、ターミナルアクセスには、「devtools」MCPサーバーが提供するツールを使用してください。
「devtools」のツールを使用する際は、常に現在のリポジトリの作業ディレクトリへの絶対パスを「repo_path」オプションとして提供してください。
「repo_path」を他のフォルダに設定しないでください。
「repo_path」は、会話の最初にユーザーから明示的に要求する必要があります。
「execute_command」ツールを使用する際、現在の作業ディレクトリは提供された「repo_path」に設定されます。
「execute_command」でファイル操作を行う場合、操作対象のファイルパスには「repo_path」プレフィックスを含む完全なパスをターミナルコマンドで渡してください。
「ai_edit」ツールを使用する際、ツールコールに実際の角括弧や他のJSONを破壊する記号を入れず、代わりにそれらを言葉で説明してください。
```

# 標準オペレーション手順（SOP）

以下の5つのステップで反復的に作業してください。

1.  分析と計画：ユーザーの要件を十分に分析し、高レベルの実装計画を立てます。課題を可能な限り小さく、論理的で、段階的に進められるステップに分解します。
2.  1ステップだけ委譲：計画の「次の1ステップ」だけを、`ai_edit` に対する正確で実行可能かつ自己完結したプロンプトに翻訳します。複数のステップを1回の委譲にまとめないでください。既定では continue_thread = false を使用し、直前の Aider 会話に基づいて明示的に継続する（同一変更の反復修正など）場合のみ continue_thread = true を設定してください。
3.  コンテキストの完全提示：エージェントは無状態で動作し得るため、そのステップを完了するのに必要なすべてのコンテキストを `ai_edit` のプロンプトに含めてください（下記「エージェント記憶モデル（条件付きステートレス）」参照）。continue_thread が true/false のいずれであっても、常に以下を含めます：
    - 編集対象ファイルのフルパス
    - 変更すべき関数／クラス／コードブロック
    - 理解に不可欠な依存スニペット（同一ファイルや他ファイルから）
4.  レビューと検証：各実行後、`ai_edit` が生成した diff を厳格に確認します。これは必須のコードレビューです。
    - 委譲した単一ステップが正しく実装されているか？
    - コード品質は十分か？
    - 見落としやエッジケースはないか？
5.  反復と誘導：
    - 承認された場合：当該ステップは完了です。次の最小ステップを委譲してください。
    - 修正が必要な場合：実装に問題があります。新しい `ai_edit` プロンプトで是正指示を与え、その特定の1ステップを完了するために必要なコンテキストを再度すべて提供してください。

注意：常に絶対パスの `repo_path` を渡し、`files` 配列を明示してください。ツール側の推測に依存しないでください。

# エージェント記憶モデル（条件付きステートレス）

- コーディングエージェントは、`continue_thread`（ai_edit の必須パラメータ）によって、過去の会話を復元して継続するか、無状態で実行するかを切り替えられます。
- continue_thread = false の場合：
  - Aider は過去のチャットを復元しません。各呼び出しを記憶のない新規エージェントとして扱ってください。
  - そのステップに必要なすべての即時コンテキスト（ファイルのフルパス、変更対象の関数／クラス、関連する依存スニペット）を常に提示してください。
- continue_thread = true の場合：
  - 同一リポジトリ／セッション内で、Aider が直前のチャット履歴を復元することで連続性を持たせられます。
  - それでも重要コンテキストの明示は必須です。チャット履歴はベストエフォートであり、明確かつ正確なコンテキストの代替にはなりません。
- 既定の推奨：continue_thread = false。明示的に「直前の Aider 会話の流れを継続したい」場合にのみ true を使用します。

## continue_thread の選び方
- false（推奨）：
  - 機能やタスクを切り替えるとき
  - リポジトリに大きな変更が入った後
  - 各プロンプト間の独立性を確保したいとき
- true：
  - 同じ機能／修正に対して直ちに反復する
  - 直前の Aider 変更の手直しを行う
  - 同一リポジトリ内で短期的に会話を再開する

## ⁉️ 既知の問題と回避策

### 💾 直接コード編集 vs 🤖 AI支援編集

**問題:**

  * 🔍 `write_to_file` ツールを直接コード編集に使用する場合、特にテンプレートリテラル（バッククォートで囲まれた文字列）を利用するJavaScriptのような言語では、予期しない構文エラーが発生することがあります。この問題は、AIアシスタントが `content` 文字列を生成する方法に起因し、テンプレートリテラル内のバッククォートやドル記号が余分なバックスラッシュ（`\`）で誤ってエスケープされる可能性があるためです。

**緩和策:**

  * 🔨 `write_to_file`、`git_apply_diff` ツールは、編集時に `.js`、`.mjs`、`.ts` ファイルの条件付き型チェックのために `tsc`（TypeScriptコンパイラ）と動的に統合されています。`tsc --noEmit --allowJs` の出力がツール応答の一部として提供されます。AIアシスタントはこの出力を解析してコンパイラエラーを検出し、エラーが報告された場合は、書き込まれたコードに問題があることを示しているため、*さらなるアクションを続行すべきではありません*。

**回避策:**

  * 🤖 （最も信頼性が高い）AIアシスタントに、`ai_edit` ツールを使用してファイルの編集をMCP互換のコーディングエージェントに委任するように指示します。これは直接的なコード操作に適しており、変更を自動的にコミットし、結果の差分をツール出力として生成します。AIアシスタントは、`write_to_file` ツールで計画やドキュメントを書き留め、実際のコーディングを専門のエージェントに委任し、そのレポート（差分）をツールコールの結果として取得し、`git_read_file` ツールでエージェントの作業を再確認し、コミットとブランチを管理するタスクオーケストレーターとして機能します（`ai_edit` ツールは基本的に[そのMCPブリッジ](https://github.com/sengokudaikon/aider-mcp-server)から移植されたロジックを介して `Aider` を統合します）。
  * 🖥️ （運が良ければ）AIアシスタントに、`execute_command` ツールを介して問題のあるファイルを編集するためのターミナルコマンドを作成するように指示します。

### ❔ Aiderのコミット優先の性質による制限

**問題:**

  * 🔍 マージ中やリベース中など、リポジトリがダーティな状態で `ai_edit` ツールを使用すると、コミットを適用しようとしてスタックする可能性があります。

**回避策:**

  * ⚙️ `.aider.conf.yml` 設定ファイルで自動コミット機能を一時的に無効にします。

## 🙈 自動化関連のセキュリティ考慮事項

  - 🛡️ 自動化されたワークフローでは、常にMCPサーバーを隔離された環境（🐧[Firejail](https://github.com/netblue30/firejail) または 🪟[Sandboxie](https://github.com/sandboxie-plus/Sandboxie)）で実行してください。
  - 🗃️ ファイルシステムへのアクセス境界は、すべてのツールコールに `repo_path` を渡すことで維持されます。これにより、AIアシスタントは現在のワークスペース内のファイル（AIが `repo_path` として渡すことを決定した任意のパスからの相対パス）に対してのみ読み取り/書き込みアクセス権を持ちます。システムプロンプトがcwdの使用に関して堅牢であることを確認してください。
  - ⚠️ `execute_command` には厳格なアクセス境界が定義されていません。すべてのコマンドは `repo_path` をcwdとして実行しますが（それからの相対パス）、AIが他の場所にフルパスを渡すのを止めるものは何もありません。コンピュータ全体の意図しないデータを読み取ったり、変更したり、削除したりする可能性があるため、`execute_command` ツールを自動許可する場合は特に注意を払うか、少なくともAIアシスタントを無人で実行させないでください。MCPサーバーは、AIアシスタントがホームフォルダで `rm -rf *` を実行したことについて責任を負いません。

## ℹ️ 利用可能なツール

### `git_status`

  - **説明:** Gitワーキングツリーの現在の状態（追跡されていないファイル、変更されたファイル、ステージされたファイルなど）を表示します。
  - **入力スキーマ:**
    ```json
    {
      "type": "object",
      "properties": {
        "repo_path": {
          "type": "string",
          "description": "Gitリポジトリのワーキングディレクトリへの絶対パス。"
        }
      },
      "required": [
        "repo_path"
      ]
    }
    ```


### `git_diff`

  - **説明:** ワーキングディレクトリの差分を表示します。デフォルト（ターゲットなし）では、`git diff` のようにワーキングツリーとインデックスの差分を表示します。以前の「HEAD とのすべての変更」の動作には target='HEAD' を渡してください。
  - **入力スキーマ:**
    ```json
    {
      "type": "object",
      "properties": {
        "repo_path": {
          "type": "string",
          "description": "Gitリポジトリのワーキングディレクトリへの絶対パス。"
        },
        "target": {
          "type": "string",
          "description": "オプション。省略した場合、`git diff` のようにワーキングツリーとインデックスを比較します。コミットまたはブランチと比較するには 'HEAD' または他の参照を渡します。"
        }
      },
      "required": [
        "repo_path"
      ]
    }
    ```

### `git_stage_and_commit`

  - **説明:** 指定されたファイル（ファイルが指定されていない場合はすべての変更）をステージし、指定されたメッセージでリポジトリにコミットします。これにより、Git履歴に新しいコミットが作成されます。
  - **入力スキーマ:**
    ```json
    {
      "type": "object",
      "properties": {
        "repo_path": {
          "type": "string",
          "description": "Gitリポジトリのワーキングディレクトリへの絶対パス。"
        },
        "message": {
          "type": "string",
          "description": "変更内容のコミットメッセージ。"
        },
        "files": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "コミットする前にステージする特定のファイルパスのオプションのリスト（リポジトリルートからの相対パス）。提供されない場合、すべての変更がステージされます。"
        }
      },
      "required": [
        "repo_path",
        "message"
      ]
    }
    ```

### `git_log`

  - **説明:** リポジトリのコミット履歴を表示し、最近のコミットをハッシュ、作成者、日付、メッセージとともに一覧表示します。コミット数は制限できます。
  - **入力スキーマ:**
    ```json
    {
      "type": "object",
      "properties": {
        "repo_path": {
          "type": "string",
          "description": "Gitリポジトリのワーキングディレクトリへの絶対パス。"
        },
        "max_count": {
          "type": "integer",
          "default": 10,
          "description": "取得するコミットエントリの最大数。デフォルトは10です。"
        }
      },
      "required": [
        "repo_path"
      ]
    }
    ```

### `git_create_branch`

  - **説明:** 指定された名前で新しいGitブランチを作成します。オプションで、既存のブランチやコミットを基に新しいブランチを作成できます。そうでない場合は、現在アクティブなブランチを基にします。
  - **入力スキーマ:**
    ```json
    {
      "type": "object",
      "properties": {
        "repo_path": {
          "type": "string",
          "description": "Gitリポジトリのワーキングディレクトリへの絶対パス。"
        },
        "branch_name": {
          "type": "string",
          "description": "作成する新しいブランチの名前。"
        },
        "base_branch": {
          "type": "string",
          "nullable": true,
          "description": "オプション。新しいブランチの基にするブランチ名またはコミットハッシュ。提供されない場合、新しいブランチは現在アクティブなブランチを基にします。"
        }
      },
      "required": [
        "repo_path",
        "branch_name"
      ]
    }
    ```

### `git_checkout`

  - **説明:** 現在アクティブなブランチを指定されたブランチ名に切り替えます。これにより、ワーキングディレクトリがターゲットブランチの状態を反映するように更新されます。
  - **入力スキーマ:**
    ```json
    {
      "type": "object",
      "properties": {
        "repo_path": {
          "type": "string",
          "description": "Gitリポジトリのワーキングディレクトリへの絶対パス。"
        },
        "branch_name": {
          "type": "string",
          "description": "チェックアウトするブランチの名前。"
        }
      },
      "required": [
        "repo_path",
        "branch_name"
      ]
    }
    ```

### `git_show`

  - **説明:** 特定のコミットまたはコミット範囲（A..BまたはA...B）のメタデータ（作成者、日付、メッセージ）と差分を表示します。これにより、特定のコミットまたはコミット範囲によって導入された変更を検査できます。オプションでパスフィルターまたはメタデータのみ/差分のみ表示が可能です。
  - **入力スキーマ:**
    ```json
    {
      "type": "object",
      "properties": {
        "repo_path": {
          "type": "string",
          "description": "Gitリポジトリのワーキングディレクトリへの絶対パス。"
        },
        "revision": {
          "type": "string",
          "description": "詳細を表示するコミットハッシュ、参照（例：「HEAD」、「main」、「abc1234」）または範囲（A..BまたはA...B）。"
        },
        "path": {
          "type": "string",
          "description": "オプション。指定されたファイルパスの変更のみを表示するように出力をフィルタリングします。"
        },
        "show_metadata_only": {
          "type": "boolean",
          "description": "オプション。trueの場合、差分なしでコミットメタデータ（作成者、日付、メッセージ）のみを表示します。"
        },
        "show_diff_only": {
          "type": "boolean",
          "description": "オプション。trueの場合、コミットメタデータなしで差分のみを表示します。"
        }
      },
      "required": [
        "repo_path",
        "revision"
      ]
    }
    ```

### `git_apply_diff`

  - **説明:** 指定された差分コンテンツ（unified diff形式）をリポジトリのワーキングディレクトリに適用します。これは、パッチや変更をプログラムで適用するために使用できます。
  - **入力スキーマ:**
    ```json
    {
      "type": "object",
      "properties": {
        "repo_path": {
          "type": "string",
          "description": "Gitリポジトリのワーキングディレクトリへの絶対パス。"
        },
        "diff_content": {
          "type": "string",
          "description": "リポジトリに適用する差分コンテンツの文字列。これはunified diff形式である必要があります。"
        }
      },
      "required": [
        "repo_path",
        "diff_content"
      ]
    }
    ```

### `git_read_file`

  - **説明:** Gitリポジトリのワーキングディレクトリ内にある指定されたファイルの全コンテンツを読み込んで返します。ファイルパスはリポジトリのルートからの相対パスでなければなりません。
  - **入力スキーマ:**
    ```json
    {
      "type": "object",
      "properties": {
        "repo_path": {
          "type": "string",
          "description": "Gitリポジトリのワーキングディレクトリへの絶対パス。"
        },
        "file_path": {
          "type": "string",
          "description": "読み取るファイルのパス（リポジトリのワーキングディレクトリからの相対パス）。"
        }
      },
      "required": [
        "repo_path",
        "file_path"
      ]
    }
    ```

### `write_to_file`

  - **説明:** 提供されたコンテンツを指定されたファイルに書き込みます。ファイルが存在しない場合は作成されます。存在する場合は、そのコンテンツは完全に上書きされます。コンテンツが正しく書き込まれたかを確認するチェックと差分の生成が含まれます。
  - **入力スキーマ:**
    ```json
    {
      "type": "object",
      "properties": {
        "repo_path": {
          "type": "string",
          "description": "Gitリポジトリのワーキングディレクトリへの絶対パス。"
        },
        "file_path": {
          "type": "string",
          "description": "書き込むファイルのパス（リポジトリのワーキングディレクトリからの相対パス）。ファイルが存在しない場合は作成され、存在する場合は上書きされます。"
        },
        "content": {
          "type": "string",
          "description": "指定されたファイルに書き込む文字列コンテンツ。"
        }
      },
      "required": [
        "repo_path",
        "file_path",
        "content"
      ]
    }
    ```

### `execute_command`

  - **説明:** 指定されたリポジトリのワーキングディレクトリのコンテキスト内で任意のシェルコマンドを実行します。このツールは、ビルドスクリプトの実行、リンター、その他のシステムコマンドなど、他の特定のGitツールでカバーされていないタスクに使用できます。
  - **入力スキーマ:**
    ```json
    {
      "type": "object",
      "properties": {
        "repo_path": {
          "type": "string",
          "description": "コマンドが実行されるべきディレクトリへの絶対パス。"
        },
        "command": {
          "type": "string",
          "description": "実行するシェルコマンドの文字列（例：「ls -l」、「npm install」）。"
        }
      },
      "required": [
        "repo_path",
        "command"
      ]
    }
    ```

### `ai_edit`

  - **説明:** Aiderを使用して対象を絞ったコード変更を行うためのAIペアプログラミングツール。このツールを使用して、次のことを行います。

    1.  既存のコードに新しい機能や機能性を実装する
    2.  既存のコードベースにテストを追加する
    3.  コードのバグを修正する
    4.  既存のコードをリファクタリングまたは改善する
    5.  複数のファイルにわたる構造的な変更を行う

    このツールには以下が必要です。

      - コードが存在するリポジトリのパス
      - どのような変更を行うかを説明する詳細なメッセージ。メッセージごとに1つの変更のみを記述してください。複数の変更を行う必要がある場合は、複数のリクエストを送信してください。

    **編集フォーマットの選択:**
    `edit_format` オプションが明示的に提供されていない場合、デフォルトはモデル名に基づいて選択されます。

      - モデル名に `gemini` が含まれている場合、`diff-fenced` にデフォルト設定されます
      - モデル名に `gpt` が含まれている場合、`udiff` にデフォルト設定されます
      - それ以外の場合、`diff` にデフォルト設定されます

    メッセージのベストプラクティス：

      - どのファイルやコンポーネントを変更するかを具体的に記述する
      - 望ましい動作や機能性を明確に説明する
      - 既存のコードベースの構造に関するコンテキストを提供する
      - 従うべき制約や要件を含める

    良いメッセージの例：

      - 「src/models/customer.rbのCustomerクラスに、検証ロジックをテストする単体テストを追加してください」
      - 「controllers/users\_controller.jsファイルのユーザー一覧APIにページネーションを実装してください」
      - 「utils/date\_formatter.pyで1970年以前の日付が正しく処理されないバグを修正してください」
      - 「middleware/auth.jsの認証ミドルウェアを、コールバックの代わりにasync/awaitを使用するようにリファクタリングしてください」

  - **入力スキーマ:**

    ```json
    {
      "type": "object",
      "properties": {
        "repo_path": {
          "type": "string",
          "description": "AI編集が行われるべきGitリポジトリのワーキングディレクトリへの絶対パス。"
        },
        "message": {
          "type": "string",
          "description": "行うべきコードの変更を説明する詳細な自然言語のメッセージ。ファイル、望ましい動作、および制約について具体的に記述してください。"
        },
        "files": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Aiderが操作すべきファイルパスのリスト（リポジトリルートからの相対パス）。この引数は必須です。"
        },
        "continue_thread": {
          "type": "boolean",
          "description": "必須。チャット履歴を復元してAiderスレッドを継続するかどうか。trueの場合は--restore-chat-historyを、falseの場合は--no-restore-chat-historyを渡します。クライアントは明示的に選択する必要があります。"
        },
        "options": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "オプション。Aiderに直接渡す追加のコマンドラインオプションのリスト。各オプションは文字列である必要があります。"
        },
        "edit_format": {
          "type": "string",
          "enum": [
            "diff",
            "diff-fenced",
            "udiff",
            "whole"
          ],
          "default": "diff",
          "description": "オプション。Aiderが編集に使用するフォーマット。デフォルトは「diff」です。オプション：「diff」、「diff-fenced」、「udiff」、「whole」。"
        }
      },
      "required": [
        "repo_path",
        "message",
        "files",
        "continue_thread"
      ]
    }
    ```

## 使用例（ステートレス vs チャット復元）
- ステートレス（推奨）：
  - continue_thread: false
  - その1ステップを完了するために必要なコンテキストを毎回すべて含める
- チャット復元：
  - continue_thread: true
  - 重要コンテキストは引き続き明示してください（チャット履歴だけに依存しない）
  - 直前の実行で行った変更の修正や微調整に最適

> 注意: `continue_thread` が false の場合、Aider 実行前にリポジトリルートの `.aider.chat.history.md` を空にしてチャットメモリを剪定します。

> 追記: Aider 完了後、サーバーは `.aider.chat.history.md`（直近のセッションのみ）から最後の Aider 返信をツール出力に付加し、可読性のために SEARCH/REPLACE のノイズを除去します。

### `aider_status`

  - **説明:** Aiderとその環境の状態を確認します。これを使用して、次のことを行います。
    1.  Aiderが正しくインストールされていることを確認する
    2.  APIキーを確認する
    3.  現在の設定を表示する
    4.  接続またはセットアップの問題を診断する
  - **入力スキーマ:**
    ```json
    {
      "type": "object",
      "properties": {
        "repo_path": {
          "type": "string",
          "description": "Aiderの状態を確認するGitリポジトリまたはワーキングディレクトリへの絶対パス。"
        },
        "check_environment": {
          "type": "boolean",
          "default": true,
          "description": "trueの場合、ツールはAiderの設定、環境変数、およびGitリポジトリの詳細も確認します。デフォルトはtrueです。"
        }
      },
      "required": [
        "repo_path"
      ]
    }
    ```
